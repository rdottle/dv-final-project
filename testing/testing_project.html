<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Cloropleth map</title>
  </head>

  <style type="text/css">
    /*CSS goes here */
  </style>
  
  <body>
    <!-- page elements go here -->
    <h1> map headline goes here </h1>
      <div id="option">
    <input name="updateButton" 
                 type="button" 
                value="A" 
                onclick="updateDataFIPS()">
</div>
  <input name="updateButton" 
                 type="button" 
                value="B" 
                onclick="updateDataYear()">
</div>
  <input name="updateButton" 
                 type="button" 
                value="C" 
                onclick="updateDataPop()">
</div>

    <div class="chloroplethMap"> </div>
    <div class="source">
      <span class="sourceTitle"></span>
      <span class="sourceText"></span>
    </div>

  </body>
  
  <script src="http://d3js.org/d3.v4.min.js"></script>
  <script src="http://d3js.org/d3-queue.v3.min.js"></script>  
  <script src="http://d3js.org/topojson.v1.min.js"></script>    
  <link rel="stylesheet" type="text/css" href="testing_NTA.css">

  <script type="text/javascript">
  //Creates tooltip and makes it invisiblae
  var div = d3.select(".chloroplethMap").append("div")
    .attr("class", "tooltip")
    .style("opacity", 0);

  //using svg element to display the map on 
  var width = 970;
      height = 560;

  var projection = d3.geoMercator()
      .center([-73.94, 40.70]) //sets a single standard parallel at selected lat 
      .scale(50000) //obvi scale of the map 
      .translate([width / 2, height / 2]); //a pixel offset that's commonly specified to ensure that the center of the projection is in the center of the viewing area

  var path = d3.geoPath()
      .projection(projection);

  //sets/creates svg window  
  var svg = d3.select(".chloroplethMap").append("svg")
      .attr("width", width)
      .attr("height", height)

  //SETTING COLORS FOR THE LEGEND
  var legend_color_domain = [5, 10, 15, 20, 25] //LOWER LIMIT
  var legend_labels = ["1000", "5000", "30000", "60000", "80000"]  

  //setting the color range using a color function
  var color= d3.scaleThreshold()
      .domain([5, 10, 15, 20, 25]) //this is the input break values 
      .range(["#f2f0f7", "#dadaeb", "#bcbddc", "#9e9ac8", "#756bb1", "#54278f"]);


  d3.queue()  
      .defer(d3.json, "nybb.json")
      .defer(d3.json, "nta_review_wordfreqs.json") 
      .await(ready); //Run 'ready' when JSONs are loaded

//FREQS: affordable, barfreq, busyfreq, cozyfreq, diversefre, hipsterfre, historicfr, luxuryfreq, modernfreq, parkfreq, quietfreq
//county_fip, ntacode, ntaname
 //BASIC 
  function ready(error, nyc, frequency) { //error, var1, var2
    if (error) throw error;
    console.log(nyc)
    console.log(frequency)
    console.log(frequency.value)
    console.log(nyc.value);

    var affordableFreq = {};
 
    frequency.forEach(function(d) {
      affordableFreq[d.ntaname] = +d.affordable; 
    });

    //here we are seperating the features so we can style them through svg.selectAll(".newclasswearemaking")
    svg.append("g")
        .attr("class", "nta") //i define the class 
      .selectAll("path")
        .data(topojson.feature(nyc, nyc.objects.nta_review_wordfreqs).features) // Bind TopoJSON data elements - this has to be basically the name of the file under the objects in the json 
      .enter().append("path")
        .attr("d", path)
        // get population value for specific object based on selected fieldname earlier
        // pass population to color function, return color based on scale 
        .style("fill", function(d) {
          return color(affordableFreq[d.properties.ntaname]);
        })
        .style("stroke", "white")
        .style("stroke-width", "0.1")

  //adding outline for borough boundaries 
   svg.append("path")
    .datum(topojson.mesh(nyc, nyc.objects.nybb))
    .attr("class", "boroughs") 
    .attr("d", path)
};

// //FIPS
//   d3.queue()  
//       .defer(d3.json, "nyc_nta_bb.json") //load file containing neighborhood tabulation area and borough boundaries as layers
//       .defer(d3.csv, "Pop_NTA.csv") //load population file
//       .await(updateDataFIPS);

//  function updateDataFIPS(error, nyc, population) { //error, var1, var2
//     if (error) throw error;
//     console.log(nyc);

//     var fipsByID= {};
 
//     population.forEach(function(d) {
//       fipsByID[d.ntaname] = +d.county_fips;
//     });

//     svg.append("g")
//         .attr("class", "nta") 
//       .selectAll("path")
//         .data(topojson.feature(nyc, nyc.objects.NY_NTA).features) 
//       .enter().append("path")
//         .attr("d", path)
//         .style("fill", function(d) {
//           return color(fipsByID[d.properties.ntaname]); 
//         })
//         .style("stroke", "white")
//         .style("stroke-width", "0.1")
  
//   //adding outline for borough boundaries 
//    svg.append("path")
//     .datum(topojson.mesh(nyc, nyc.objects.nybb)) 
//     .attr("class", "boroughs") 
//     .attr("d", path)
// };

// //YEAR
//   d3.queue()  
//       .defer(d3.json, "nyc_nta_bb.json") //load file containing neighborhood tabulation area and borough boundaries as layers
//       .defer(d3.csv, "Pop_NTA.csv") //load population file
//       .await(updateDataYear);

//  function updateDataYear(error, nyc, population) { //error, var1, var2
//     if (error) throw error;
//     console.log(nyc);

//     var yearByID= {};
 
//     population.forEach(function(d) {
//       yearByID[d.ntaname] = +d.Year;
//     });

//     svg.append("g")
//         .attr("class", "nta") 
//       .selectAll("path")
//         .data(topojson.feature(nyc, nyc.objects.NY_NTA).features) 
//       .enter().append("path")
//         .attr("d", path)
//         .style("fill", function(d) {
//           return color(yearByID[d.properties.ntaname]); 
//         })
//         .style("stroke", "white")
//         .style("stroke-width", "0.1")
  
//   //adding outline for borough boundaries 
//    svg.append("path")
//     .datum(topojson.mesh(nyc, nyc.objects.nybb)) 
//     .attr("class", "boroughs") 
//     .attr("d", path)
// };

// //POP
//   d3.queue()  
//       .defer(d3.json, "nyc_nta_bb.json") //load file containing neighborhood tabulation area and borough boundaries as layers
//       .defer(d3.csv, "Pop_NTA.csv") //load population file
//       .await(updateDataPop);

//  function updateDataPop(error, nyc, population) { //error, var1, var2
//     if (error) throw error;
//     console.log(nyc);

//     var popByID= {};
 
//     population.forEach(function(d) {
//       popByID[d.ntaname] = +d.Year;
//     });

//     svg.append("g")
//         .attr("class", "nta") 
//       .selectAll("path")
//         .data(topojson.feature(nyc, nyc.objects.NY_NTA).features) 
//       .enter().append("path")
//         .attr("d", path)
//         .style("fill", function(d) {
//           return color(popByID[d.properties.ntaname]); 
//         })
//         .style("stroke", "white")
//         .style("stroke-width", "0.1")
  
//   //adding outline for borough boundaries 
//    svg.append("path")
//     .datum(topojson.mesh(nyc, nyc.objects.nybb)) 
//     .attr("class", "boroughs") 
//     .attr("d", path)
// };

  //appends chart source text 
   d3.select(".sourceTitle")
    .text("SOURCE: ")
    .attr("class", "sourceTitle");

   d3.select(".sourceText")
    .text("Department of City Planning (2017), Inside AirBnB (2017)")
    .attr("class", "sourceText");

  //drawing legend for chloropleth
   var legend = svg.selectAll("g.legend")
    .data(legend_color_domain)
    .enter().append("g")
    .attr("class", "legend");

    var legendRectWidth = 20, legendRectHeight = 20; //width and height

    legend.append("rect") //legend boxes
    .attr("x", 20) //horizontal location
    .attr("y", function(d, i){ return height - (i*legendRectHeight) - 2*legendRectHeight;}) //vertical location
    .attr("width", legendRectWidth)
    .attr("height", legendRectHeight)
    .style("fill", function(d, i) { return color(d); })
    .style("opacity", 0.8);

    legend.append("text") //legend text
    .attr("class", "legendText") //gives it class so can edit in css
    .attr("x", 50) //positioning
    .attr("y", function(d, i){ return height - (i*legendRectHeight) - legendRectHeight - 4;}) //multiplying by i puts all the boxes
    .text(function(d, i){ return legend_labels[i]; });

    legend.append("text")
    .attr("class", "legendHeading")
    .attr("x", 20)
    .attr("y", function(d){ return height - 6 - legendRectHeight * 6;}) //multiplying and subtractingincreases the height vertically
    .text("Population in New York City")

  </script>   

</html>